---
layout: post
title: "Two Sum"
date: 2013-04-29 15:47
comments: true
categories: leetcode
---

## Problem

Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

**Input**: numbers={2, 7, 11, 15}, target=9

**Output**: index1=1, index2=2

## Discussion

This is a classical problem. One solution is like this: first sort it, then for every element x in the array, binary search for its complement (target - x). 

This solution can be improved without using the binary search. In a sorted array, consider the following algorithm:

	Initially i = 0, j = n-1. 
	while a[i] + a[j] != target:
		If a[i] + a[j] < target: 
			// the sum must increase
			i = i + 1
		else if a[i] + a[j] > target: 
			// the sum must decrease 
	    	j = j - 1 

Why does this algorithm work? It seems obvious but it takes time to prove it correct. Look at the graph below:

![the loop invarience](/images/twosum.png "the loop invarience")

We have the invariance: for any 0 <= x < i and j < y < n, a[x] + a[y] != target. Initially i = 0, j = n-1 and this is true. Next we want to prove when a[i] + a[j] < target, then for any 0 <= x < i+1 and j < y < n, a[x] + a[y] != target. If x < i, this is true due to the invariance before the iteration. If x = i, notice for j to be here, there must be some number 0 <= x0 < i such that a[x0] + a[j+1] > target. Hence, a[i] + a[y] >= a[x0] + a[j+1] > target. This means, for x = i, a[x] + a[y] != target. Thus for any 0 <= x < i+1 and j < y < n, a[x] + a[y] != target, the invariance is kept.

Similarly we can prove that when a[i] + a[j] > target, then for any 0 <= x < i and j - 1 < y < n, a[x] + a[y] != target. The invariance, together with the loop guard a[i] + a[j] != target, implies a[i] + a[j] = target when the loop terminates.

Bear in mind that the program must return the indices in the __original__ array, not the indices in the sorted one. Hence we must find the original indices for a[i] and  a[j]. There is a "gotcha" here, consider the following code for finding the original index:

{% codeblock find original index lang:c %}
	
	int index1, index2;
    for (int k = 0; k < n; k++) {
        if (sorted[i] == numbers[k]) {
            index1 = k+1; // notice index1 and index2 are NOT zero-based.
        } else if (sorted[j] == numbers[k]) {
            index2 = k+1;
        }
    }
	
{% endcodeblock %}

What's the problem here? If we have [25, 25, 10] and the target 50, both the index1 and index2 will be 2! Hence we  restrict index1 to be assigned only once, and thus index1 != index2 is satisfied.

## Solution

{% codeblock TwoSum lang:c %}

class Solution {
public:
    vector<int> twoSum(vector<int> &numbers, int target) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        
        // create a sorted copy
        vector<int> sorted(numbers.begin(), numbers.end());
        sort(sorted.begin(), sorted.end());
        
        // initialization
        int n = sorted.size();
        int i = 0, j = n - 1;
        
        int sum;
        // invariance: sorted[x] + sorted[y] != target for all 0 < x < i and  j < y < n
        while (i < j && (sum = sorted[i] + sorted[j]) != target) {
            if (sum < target) {
                i++;
            } else {
                // sum > target
                j--;
            }
        }
        
        // sorted[i] + sorted[j] == target
        int index1 = -1, index2 = -1;
        for (int k = 0; k < n; k++) {
            // this way , we can ensure index1 != index2 even when sorted[i] == sorted[j]
            if (index1 == -1 && sorted[i] == numbers[k]) {
                index1 = k+1; // notice index1 and index2 are NOT zero-based.
            } else if (sorted[j] == numbers[k]) {
                index2 = k+1;
            }
        }
        
        if (index1 > index2) {
            swap(index1, index2);
        }
        
        vector<int> result;
        result.push_back(index1);
        result.push_back(index2);
        
        return result;
    }
};
	
{% endcodeblock %}








 